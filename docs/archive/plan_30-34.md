# ROADMAP: Implementation Guide for NLD-30 & NLD-34

**Project:** Centre Auth Service (CAS)  
**Epic:** Supplier Management Enhancement  
**Tasks:**
- **NLD-34:** Implement Supplier Deactivation/Activation Feature
- **NLD-30:** Add Station Assignment for Suppliers

**Status:** Ready for Implementation  
**Target Completion:** TBD  
**Complexity:** Medium (Combined tasks to optimize migration and PR process)

---

## Table of Contents

- [Overview](#overview)
- [Business Requirements](#business-requirements)
- [Technical Specification](#technical-specification)
- [Implementation Roadmap](#implementation-roadmap)
- [Testing Strategy](#testing-strategy)
- [Deployment Checklist](#deployment-checklist)

---

## Overview

### Task Summary

| Task ID | Feature | Database Impact | API Changes | Priority |
|---------|---------|-----------------|-------------|----------|
| NLD-34  | Supplier Deactivation | Add `is_deactivate` column | Update/Toggle Status API | High |
| NLD-30  | Station Assignment | Add `station_id` column | Assign/Update Station | Medium |

### Why Combine Tasks?

Both tasks modify the same database table (`suppliers`) and proto file (`supplier.proto`). Combining them:
- Reduces migration file count
- Simplifies code review process
- Minimizes database schema changes
- Creates atomic feature delivery

### Key Dependencies

- **Proto Repository:** `Core/proto/supplier/v1/supplier.proto`
- **Backend Repository:** `centre-auth-service`
- **Migration Base:** Current migration is `063_rename_supplier_columns.sql`
- **New Migration Number:** `064_update_supplier_schema.sql`

---

## Business Requirements

### NLD-34: Supplier Deactivation

**User Story:**  
As an Admin user on Hub/HQ Portal, I want to deactivate/activate suppliers so that I can control who can operate on the platform.

**Acceptance Criteria:**
1. Admin can toggle supplier status via Portal UI
2. When `is_deactivate = true`:
   - Supplier cannot access supplier channel on mobile app
   - System displays "Account temporarily locked" message
   - User is redirected to homepage
3. System should support future enhancement: Force logout when status changes

**Business Rules:**
- Default status: Active (`is_deactivate = false`)
- Only Admin/HQ users can change status
- Status change should be logged (future enhancement)

### NLD-30: Station Assignment

**User Story:**  
As an Admin user, I want to assign suppliers to specific stations so that I can manage suppliers by geographical regions.

**Acceptance Criteria:**
1. Admin can view station information in supplier listing
2. Admin can manually assign/reassign stations via detail page
3. System auto-assigns station based on supplier's operating area (address) when creating new supplier
4. Station assignment can be updated anytime

**Business Rules:**
- Station assignment is optional initially
- Auto-assignment logic: Match Province/District/Ward with station coverage area
- Manual assignment overrides auto-assignment

---

## Technical Specification

### Database Schema Changes

**Table:** `suppliers`

| Column Name | Data Type | Default | Nullable | Index | Description |
|-------------|-----------|---------|----------|-------|-------------|
| `is_deactivate` | BOOLEAN | false | NO | - | Supplier active status |
| `station_id` | VARCHAR(50) | NULL | YES | YES | Assigned station ID |

**Migration File:** `064_update_supplier_schema.sql`

```sql
-- Task NLD-34: Add deactivation status
ALTER TABLE suppliers 
ADD COLUMN IF NOT EXISTS is_deactivate BOOLEAN DEFAULT FALSE;

COMMENT ON COLUMN suppliers.is_deactivate IS 
'Supplier active status: false = Active, true = Deactivate';

-- Task NLD-30: Add station assignment
ALTER TABLE suppliers 
ADD COLUMN IF NOT EXISTS station_id VARCHAR(50);

-- Create index for station filtering
CREATE INDEX IF NOT EXISTS idx_suppliers_station_id 
ON suppliers(station_id);

COMMENT ON COLUMN suppliers.station_id IS 
'Assigned station ID for regional management';
```

### Proto Definition Updates

**File:** `Core/proto/supplier/v1/supplier.proto`

**Update Message `Supplier`:**
```protobuf
message Supplier {
  // ... existing fields
  
  // NLD-34: Deactivation status
  bool is_deactivate = 20;
  
  // NLD-30: Station assignment
  string station_id = 21;
}
```

**Update Message `SupplierData`:**
```protobuf
message SupplierData {
  // ... existing fields
  
  bool is_deactivate = 25;
  string station_id = 26;
}
```

**Update/Create Request Messages:**
Ensure `CreateSupplierRequest` and `UpdateSupplierRequest` include these fields.

### Code Structure Changes

#### Domain Layer
**File:** `internal/domain/supplier.go`

```go
type Supplier struct {
    ID         string    `json:"id" db:"id"`
    Name       string    `json:"name" db:"name"`
    // ... existing fields
    
    // NLD-34
    IsDeactivate bool      `json:"is_deactivate" db:"is_deactivate"`
    
    // NLD-30
    StationID  string    `json:"station_id" db:"station_id"`
}
```

#### Repository Layer
**File:** `internal/repository/supplier_repository.go`

**Update Required Methods:**
1. `Create()` - Include `station_id` in INSERT
2. `Update()` - Include both new fields in UPDATE
3. `GetByID()` / `Find()` - SELECT both new columns
4. (Optional) `UpdateStatus()` - Dedicated method for status toggle

**Example Update Query:**
```go
query := `
    UPDATE suppliers 
    SET name = $1, 
        station_id = $2, 
        is_deactivate = $3,
        updated_at = NOW()
    WHERE id = $4 
    AND deleted_at IS NULL
`
```

#### Service Layer
**File:** `internal/services/supplier_service.go`

**New/Updated Methods:**

```go
// NLD-34: Toggle supplier status
func (s *supplierService) ToggleActiveStatus(
    ctx context.Context, 
    id string, 
    isDeactivate bool,
) error {
    // 1. Validate supplier exists
    supplier, err := s.repo.GetByID(ctx, id)
    if err != nil {
        return err
    }
    
    // 2. Update status
    return s.repo.UpdateStatus(ctx, id, isDeactivate)
}

// NLD-30: Assign station
func (s *supplierService) AssignStation(
    ctx context.Context, 
    supplierID string, 
    stationID string,
) error {
    // 1. Validate station exists (call Station Service)
    // 2. Update supplier's station_id
    return s.repo.UpdateStation(ctx, supplierID, stationID)
}
```

#### API/Handler Layer
**File:** `internal/grpc/supplier_handler.go`

Map proto requests to service calls.

---

## Implementation Roadmap

This section provides a step-by-step guide following enterprise Git workflow and best practices.

### Phase 0: Environment Setup & Prerequisites

**Checklist:**
- [ ] Access to both repositories: `Core` and `centre-auth-service`
- [ ] Azure DevOps credentials configured
- [ ] Local development environment running
- [ ] Database access configured
- [ ] Latest migration number verified (currently: 063)

**Git Configuration:**
```bash
# Configure Azure DevOps credentials
git config --global url."https://token:YOUR_PAT@dev.azure.com/".insteadOf "https://dev.azure.com/"
```

---

### Phase 1: Proto Update (Core Repository)

**Branch:** `feature/update-supplier-proto`

**Step 1.1: Create Feature Branch**
```bash
cd Core
git checkout develop
git pull origin develop
git checkout -b feature/update-supplier-proto
```

**Step 1.2: Update Proto File**

Edit `Core/proto/supplier/v1/supplier.proto`:

1. Add fields to `Supplier` message (around line 20-30)
2. Add fields to `SupplierData` message (around line 150+)
3. Update `CreateSupplierRequest` if needed
4. Update `UpdateSupplierRequest` if needed

**Step 1.3: Generate Proto Code**
```bash
# Run proto generation
make gen-proto
# or
buf generate
```

**Step 1.4: Commit & Push**
```bash
git add proto/supplier/v1/supplier.proto gen/
git commit -m "feat(proto): add is_deactivate and station_id to Supplier

- Add is_deactivate field for NLD-34 (deactivation feature)
- Add station_id field for NLD-30 (station assignment)
- Update SupplierData message for response
- Update request messages for create/update operations"

git push origin feature/update-supplier-proto
```

**Step 1.5: Create Pull Request**
- Create PR to `develop` branch
- Wait for review and approval
- Do NOT proceed to Phase 2 until proto changes are merged and published

---

### Phase 2: Backend Implementation (centre-auth-service)

**Branch:** `feature/NLD-30-34-supplier-enhancement`

**Step 2.1: Update Dependencies**
```bash
cd centre-auth-service
git checkout develop
git pull origin develop
git checkout -b feature/NLD-30-34-supplier-enhancement

# Update Core dependency to latest
go get dev.azure.com/agris-agriculture/Core@latest
go mod tidy
```

**Step 2.2: Create Migration File**

Create `migrations/064_update_supplier_schema.sql`:

```sql
-- Migration: 064 - Add supplier deactivation and station assignment
-- Tasks: NLD-34, NLD-30
-- Author: [Your Name]
-- Date: [Current Date]

-- NLD-34: Add deactivation status
ALTER TABLE suppliers 
ADD COLUMN IF NOT EXISTS is_deactivate BOOLEAN DEFAULT FALSE;

COMMENT ON COLUMN suppliers.is_deactivate IS 
'Supplier active status: false = Active, true = Deactivate';

-- NLD-30: Add station assignment
ALTER TABLE suppliers 
ADD COLUMN IF NOT EXISTS station_id VARCHAR(50);

-- Create index for station filtering
CREATE INDEX IF NOT EXISTS idx_suppliers_station_id 
ON suppliers(station_id);

COMMENT ON COLUMN suppliers.station_id IS 
'Assigned station ID for regional management';
```

**Step 2.3: Update Domain Model**

Edit `internal/domain/supplier.go`:

```go
type Supplier struct {
    ID            string     `json:"id" db:"id"`
    AccountID     string     `json:"account_id" db:"account_id"`
    Name          string     `json:"name" db:"name"`
    Phone         string     `json:"phone" db:"phone"`
    BusinessType  int        `json:"business_type" db:"business_type"`
    // ... other existing fields
    
    // NLD-34: Deactivation status
    IsDeactivate    bool       `json:"is_deactivate" db:"is_deactivate"`
    
    // NLD-30: Station assignment
    StationID     string     `json:"station_id" db:"station_id"`
    
    CreatedAt     time.Time  `json:"created_at" db:"created_at"`
    UpdatedAt     time.Time  `json:"updated_at" db:"updated_at"`
    DeletedAt     *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
}
```

**Step 2.4: Update Repository Layer**

Edit `internal/repository/supplier_repository.go`:

**Update Create Method:**
```go
func (r *supplierRepository) Create(ctx context.Context, supplier *domain.Supplier) error {
    query := `
        INSERT INTO suppliers (
            id, account_id, name, phone, business_type,
            is_deactivate, station_id,  -- Added fields
            created_at, updated_at
        ) VALUES (
            $1, $2, $3, $4, $5,
            $6, $7,  -- Added placeholders
            NOW(), NOW()
        )
    `
    
    _, err := r.db.ExecContext(ctx, query,
        supplier.ID,
        supplier.AccountID,
        supplier.Name,
        supplier.Phone,
        supplier.BusinessType,
        supplier.IsDeactivate,  // NLD-34
        supplier.StationID,   // NLD-30
    )
    
    return err
}
```

**Update GetByID Method:**
```go
func (r *supplierRepository) GetByID(ctx context.Context, id string) (*domain.Supplier, error) {
    query := `
        SELECT 
            id, account_id, name, phone, business_type,
            is_deactivate, station_id,  -- Added fields
            created_at, updated_at, deleted_at
        FROM suppliers
        WHERE id = $1 AND deleted_at IS NULL
    `
    
    var supplier domain.Supplier
    err := r.db.GetContext(ctx, &supplier, query, id)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, fmt.Errorf("supplier not found")
        }
        return nil, err
    }
    
    return &supplier, nil
}
```

**Update Update Method:**
```go
func (r *supplierRepository) Update(ctx context.Context, supplier *domain.Supplier) error {
    query := `
        UPDATE suppliers
        SET name = $1,
            phone = $2,
            business_type = $3,
            is_deactivate = $4,    -- NLD-34
            station_id = $5,     -- NLD-30
            updated_at = NOW()
        WHERE id = $6 AND deleted_at IS NULL
    `
    
    result, err := r.db.ExecContext(ctx, query,
        supplier.Name,
        supplier.Phone,
        supplier.BusinessType,
        supplier.IsDeactivate,
        supplier.StationID,
        supplier.ID,
    )
    
    if err != nil {
        return err
    }
    
    rows, _ := result.RowsAffected()
    if rows == 0 {
        return fmt.Errorf("supplier not found or already deleted")
    }
    
    return nil
}
```

**Add Dedicated Methods (Optional but Recommended):**
```go
// NLD-34: Update status only
func (r *supplierRepository) UpdateStatus(ctx context.Context, id string, isDeactivate bool) error {
    query := `
        UPDATE suppliers
        SET is_deactivate = $1, updated_at = NOW()
        WHERE id = $2 AND deleted_at IS NULL
    `
    
    result, err := r.db.ExecContext(ctx, query, isDeactivate, id)
    if err != nil {
        return err
    }
    
    rows, _ := result.RowsAffected()
    if rows == 0 {
        return fmt.Errorf("supplier not found")
    }
    
    return nil
}

// NLD-30: Update station only
func (r *supplierRepository) UpdateStation(ctx context.Context, id string, stationID string) error {
    query := `
        UPDATE suppliers
        SET station_id = $1, updated_at = NOW()
        WHERE id = $2 AND deleted_at IS NULL
    `
    
    result, err := r.db.ExecContext(ctx, query, stationID, id)
    if err != nil {
        return err
    }
    
    rows, _ := result.RowsAffected()
    if rows == 0 {
        return fmt.Errorf("supplier not found")
    }
    
    return nil
}
```

**Step 2.5: Update Service Layer**

Edit `internal/services/supplier_service.go`:

```go
// NLD-34: Toggle supplier active status
func (s *supplierService) ToggleActiveStatus(ctx context.Context, id string, isDeactivate bool) error {
    // Validate supplier exists
    supplier, err := s.repo.GetByID(ctx, id)
    if err != nil {
        return fmt.Errorf("failed to get supplier: %w", err)
    }
    
    if supplier == nil {
        return fmt.Errorf("supplier not found")
    }
    
    // Update status
    err = s.repo.UpdateStatus(ctx, id, isDeactivate)
    if err != nil {
        return fmt.Errorf("failed to update status: %w", err)
    }
    
    // TODO: Emit event for app notification (future enhancement)
    
    return nil
}

// NLD-30: Assign station to supplier
func (s *supplierService) AssignStation(ctx context.Context, supplierID string, stationID string) error {
    // Validate supplier exists
    supplier, err := s.repo.GetByID(ctx, supplierID)
    if err != nil {
        return fmt.Errorf("failed to get supplier: %w", err)
    }
    
    if supplier == nil {
        return fmt.Errorf("supplier not found")
    }
    
    // TODO: Validate station exists (call Station Service via gRPC)
    
    // Update station assignment
    err = s.repo.UpdateStation(ctx, supplierID, stationID)
    if err != nil {
        return fmt.Errorf("failed to assign station: %w", err)
    }
    
    return nil
}

// Update existing CreateSupplier to handle station_id
func (s *supplierService) CreateSupplier(ctx context.Context, req *CreateSupplierRequest) (*domain.Supplier, error) {
    // ... existing validation
    
    supplier := &domain.Supplier{
        ID:           uuid.New().String(),
        AccountID:    req.AccountID,
        Name:         req.Name,
        Phone:        req.Phone,
        BusinessType: req.BusinessType,
        IsDeactivate:   false,           // Default: Active
        StationID:    req.StationID,   // From request
        // ... other fields
    }
    
    // If station_id not provided, auto-assign based on address
    if supplier.StationID == "" {
        autoStation, err := s.autoAssignStation(ctx, req.Province, req.District, req.Ward)
        if err == nil && autoStation != "" {
            supplier.StationID = autoStation
        }
    }
    
    err := s.repo.Create(ctx, supplier)
    if err != nil {
        return nil, fmt.Errorf("failed to create supplier: %w", err)
    }
    
    return supplier, nil
}

// Helper: Auto-assign station based on address (NLD-30 requirement)
func (s *supplierService) autoAssignStation(ctx context.Context, province, district, ward string) (string, error) {
    // TODO: Implement station matching logic
    // Call Station Service to find matching station by address
    return "", nil
}
```

**Step 2.6: Update gRPC Handler**

Edit `internal/grpc/supplier_handler.go`:

```go
// Map proto to domain when creating/updating
func (h *supplierHandler) CreateSupplier(ctx context.Context, req *pb.CreateSupplierRequest) (*pb.CreateSupplierResponse, error) {
    // ... existing validation
    
    supplier, err := h.service.CreateSupplier(ctx, &services.CreateSupplierRequest{
        AccountID:    req.AccountId,
        Name:         req.Name,
        Phone:        req.Phone,
        BusinessType: int(req.BusinessType),
        StationID:    req.StationId,  // NLD-30
        // ... other fields
    })
    
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to create supplier: %v", err)
    }
    
    return &pb.CreateSupplierResponse{
        Supplier: h.mapDomainToProto(supplier),
    }, nil
}

// Update mapping function
func (h *supplierHandler) mapDomainToProto(supplier *domain.Supplier) *pb.Supplier {
    return &pb.Supplier{
        Id:           supplier.ID,
        AccountId:    supplier.AccountID,
        Name:         supplier.Name,
        Phone:        supplier.Phone,
        BusinessType: pb.BusinessType(supplier.BusinessType),
        IsDeactivate:   supplier.IsDeactivate,  // NLD-34
        StationId:    supplier.StationID,   // NLD-30
        // ... other fields
        CreatedAt:    timestamppb.New(supplier.CreatedAt),
        UpdatedAt:    timestamppb.New(supplier.UpdatedAt),
    }
}

// Add new RPC handlers
func (h *supplierHandler) ToggleSupplierStatus(ctx context.Context, req *pb.ToggleSupplierStatusRequest) (*pb.ToggleSupplierStatusResponse, error) {
    err := h.service.ToggleActiveStatus(ctx, req.SupplierId, req.IsDeactivate)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to toggle status: %v", err)
    }
    
    return &pb.ToggleSupplierStatusResponse{
        Success: true,
        Message: "Supplier status updated successfully",
    }, nil
}

func (h *supplierHandler) AssignSupplierStation(ctx context.Context, req *pb.AssignSupplierStationRequest) (*pb.AssignSupplierStationResponse, error) {
    err := h.service.AssignStation(ctx, req.SupplierId, req.StationId)
    if err != nil {
        return nil, status.Errorf(codes.Internal, "failed to assign station: %v", err)
    }
    
    return &pb.AssignSupplierStationResponse{
        Success: true,
        Message: "Station assigned successfully",
    }, nil
}
```

**Step 2.7: Run Migration**
```bash
# Apply migration to local database
make migrate-up

# Verify migration applied
psql -d your_database -c "\d suppliers"
# Should see is_deactivate and station_id columns
```

**Step 2.8: Test Locally**

Run unit tests and integration tests:
```bash
# Run all tests
make test

# Run specific tests
go test ./internal/repository/supplier_repository_test.go -v
go test ./internal/services/supplier_service_test.go -v
```

**Step 2.9: Commit & Push**
```bash
git add .
git commit -m "feat(supplier): implement NLD-30 and NLD-34

NLD-34: Supplier Deactivation
- Add is_deactivate column to suppliers table
- Implement toggle status API
- Update domain, repository, service layers

NLD-30: Station Assignment
- Add station_id column to suppliers table
- Implement station assignment logic
- Add auto-assign station on supplier creation
- Update all CRUD operations

Migration: 064_update_supplier_schema.sql
Testing: All unit tests passing"

git push origin feature/NLD-30-34-supplier-enhancement
```

**Step 2.10: Create Pull Request**
- Create PR to `develop` branch
- Link Jira tickets: NLD-30, NLD-34
- Add description with implementation details
- Request review from team lead
- Wait for approval and CI/CD pipeline to pass

---

## Testing Strategy

### Unit Testing

**Test Files to Create/Update:**

1. **Repository Tests:** `internal/repository/supplier_repository_test.go`
   - Test `Create()` with new fields
   - Test `Update()` with new fields
   - Test `UpdateStatus()` method
   - Test `UpdateStation()` method
   - Test `GetByID()` returns new fields

2. **Service Tests:** `internal/services/supplier_service_test.go`
   - Test `ToggleActiveStatus()` success case
   - Test `ToggleActiveStatus()` with non-existent supplier
   - Test `AssignStation()` success case
   - Test `AssignStation()` with invalid station
   - Test `CreateSupplier()` with auto-assign station

3. **Handler Tests:** `internal/grpc/supplier_handler_test.go`
   - Test proto mapping includes new fields
   - Test gRPC endpoints return correct data

### Integration Testing

**Test Scenarios:**

#### NLD-34: Deactivation Feature
```
Test Case 1: Activate/Deactivate Supplier
Given: A supplier exists with ID "SUP123"
When: Admin calls ToggleSupplierStatus(SUP123, is_deactivate=true)
Then: 
  - Database updated with is_deactivate=true
  - API returns success=true
  - GetSupplier(SUP123) shows is_deactivate=true

Test Case 2: Deactivate Non-existent Supplier
Given: Supplier ID "INVALID" does not exist
When: Admin calls ToggleSupplierStatus(INVALID, is_deactivate=true)
Then:
  - API returns error "supplier not found"
  - Database unchanged
```

#### NLD-30: Station Assignment
```
Test Case 3: Manual Station Assignment
Given: 
  - Supplier "SUP123" exists with station_id=null
  - Station "ST001" exists
When: Admin calls AssignSupplierStation(SUP123, ST001)
Then:
  - Database updated with station_id="ST001"
  - API returns success=true
  - GetSupplier(SUP123) shows station_id="ST001"

Test Case 4: Auto Station Assignment on Create
Given: 
  - New supplier data with address: Hanoi/Hoan Kiem
  - Station "ST_HANOI" covers Hanoi/Hoan Kiem area
When: Admin creates supplier without specifying station_id
Then:
  - Supplier created with station_id="ST_HANOI"
  - Database has correct station_id

Test Case 5: Update Station Assignment
Given: Supplier "SUP123" has station_id="ST001"
When: Admin reassigns to station "ST002"
Then:
  - Database updated to station_id="ST002"
  - Previous station_id overwritten
```

### Manual Testing with Postman/gRPC Client

**Test Data Setup:**
```sql
-- Create test supplier
INSERT INTO suppliers (id, account_id, name, phone, is_deactivate, station_id)
VALUES ('TEST_SUP_001', 'ACC_001', 'Test Supplier', '0123456789', false, null);

-- Create test station (if needed)
INSERT INTO stations (id, name, province, district)
VALUES ('TEST_STATION_001', 'Test Station', 'Hanoi', 'Hoan Kiem');
```

**gRPC Test Calls:**

1. **Test Create Supplier with Station:**
```json
{
  "account_id": "ACC_002",
  "name": "New Supplier",
  "phone": "0987654321",
  "station_id": "TEST_STATION_001"
}
```
Expected: Supplier created with station_id set

2. **Test Toggle Status:**
```json
{
  "supplier_id": "TEST_SUP_001",
  "is_deactivate": true
}
```
Expected: Supplier status changed to deactivate

3. **Test Get Supplier:**
```json
{
  "supplier_id": "TEST_SUP_001"
}
```
Expected Response includes:
```json
{
  "supplier": {
    "id": "TEST_SUP_001",
    "is_deactivate": true,
    "station_id": "TEST_STATION_001"
    // ... other fields
  }
}
```

### Database Verification Queries

```sql
-- Verify migration applied
SELECT column_name, data_type, column_default, is_nullable
FROM information_schema.columns
WHERE table_name = 'suppliers' 
  AND column_name IN ('is_deactivate', 'station_id');

-- Check index created
SELECT indexname, indexdef
FROM pg_indexes
WHERE tablename = 'suppliers' 
  AND indexname = 'idx_suppliers_station_id';

-- Test data integrity
SELECT id, name, is_deactivate, station_id
FROM suppliers
WHERE id = 'TEST_SUP_001';
```

---

## Deployment Checklist

### Pre-Deployment Verification

- [ ] All unit tests passing (`make test`)
- [ ] Integration tests passing
- [ ] Code review approved by team lead
- [ ] Migration file validated (correct number: 064)
- [ ] Proto changes merged and published in Core repo
- [ ] Backend PR merged to develop branch
- [ ] CI/CD pipeline passed all stages

### Deployment Steps

**1. Database Migration (Production)**
```bash
# Backup database first
pg_dump -h production-db -U admin -d agrios_db > backup_pre_nld30_34.sql

# Apply migration
make migrate-up ENV=production

# Verify migration
psql -h production-db -U admin -d agrios_db -c "\d suppliers"
```

**2. Application Deployment**
```bash
# Deploy backend service
kubectl rollout restart deployment/centre-auth-service -n production

# Monitor deployment
kubectl rollout status deployment/centre-auth-service -n production

# Check logs
kubectl logs -f deployment/centre-auth-service -n production
```

**3. Smoke Testing (Production)**
- [ ] Test GetSupplier API returns new fields
- [ ] Test CreateSupplier with station_id
- [ ] Test ToggleSupplierStatus
- [ ] Test AssignSupplierStation
- [ ] Verify no errors in application logs

### Rollback Plan

If issues occur:

**1. Rollback Application:**
```bash
# Revert to previous version
kubectl rollout undo deployment/centre-auth-service -n production
```

**2. Rollback Database (if needed):**
```sql
-- Remove added columns
ALTER TABLE suppliers DROP COLUMN IF EXISTS is_deactivate;
ALTER TABLE suppliers DROP COLUMN IF EXISTS station_id;
DROP INDEX IF EXISTS idx_suppliers_station_id;
```

**3. Restore Database (worst case):**
```bash
# Restore from backup
psql -h production-db -U admin -d agrios_db < backup_pre_nld30_34.sql
```

### Post-Deployment Monitoring

**Metrics to Monitor:**
- API response times for supplier endpoints
- Database query performance on suppliers table
- Error rates on new endpoints
- Station assignment success rate

**Monitoring Queries:**
```sql
-- Check usage statistics
SELECT 
    COUNT(*) as total_suppliers,
    COUNT(CASE WHEN is_deactivate = true THEN 1 END) as deactivated_suppliers,
    COUNT(CASE WHEN station_id IS NOT NULL THEN 1 END) as assigned_suppliers,
    COUNT(CASE WHEN station_id IS NULL THEN 1 END) as unassigned_suppliers
FROM suppliers
WHERE deleted_at IS NULL;

-- Check station distribution
SELECT 
    station_id,
    COUNT(*) as supplier_count
FROM suppliers
WHERE deleted_at IS NULL AND station_id IS NOT NULL
GROUP BY station_id
ORDER BY supplier_count DESC;
```

---

## Additional Resources

### Related Documentation

- **Jira Tickets:**
  - [NLD-34: Implement Supplier Deactivation](https://gmbc.atlassian.net/browse/NLD-34)
  - NLD-30: Station Assignment (link TBD)

- **PRD Documents:**
  - `docs/[Portal] - Hub & HQ Portal - Supplier Management.docx`
  - `docs/[Supplier] AgriOS App - Supplier Onboarding.docx`
  - `docs/[HO - HUB Portal] Them field tram va bo sung assign tram cho supplier.jpg`

- **Technical References:**
  - Proto Style Guide: `Core/README.md`
  - Migration Guide: `centre-auth-service/migrations/README.md`
  - Testing Standards: `centre-auth-service/docs/testing.md`

### Git Commit Message Convention

Follow conventional commits format:

```
<type>(<scope>): <subject>

<body>

<footer>
```

**Examples:**
```
feat(supplier): add deactivation and station assignment

Implements NLD-34 and NLD-30 features for supplier management.

Changes:
- Add is_deactivate column to suppliers table
- Add station_id column with index
- Implement toggle status API
- Implement station assignment logic
- Update all CRUD operations

BREAKING CHANGE: Supplier proto message updated
Closes NLD-34, NLD-30
```

### Contact & Support

**Technical Leads:**
- Backend Team Lead: [Name/Email]
- Database Admin: [Name/Email]
- DevOps: [Name/Email]

**Communication Channels:**
- Slack: #backend-team
- Teams: Centre Auth Service Team
- Email: backend-team@company.com

---

## Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2024-12-16 | Initial | Created comprehensive roadmap for NLD-30 & NLD-34 |

---

**End of Document**